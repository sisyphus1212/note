intel的vt-x技术，让虚拟机大部分指令可以直接运行在CPU中，只有少部分敏感指令需要有VMM来模拟执行。其中，每个CPU的LAPIC接收到的中断是虚拟化的开销一个大头。

 LAPIC接收到的中断分为外部中断，内部中断，IPI中断：

外部中断源主要是IO设备，重度使用的IO设备比如有网卡，磁盘控制器等。目前，dpdk，spdk技术在虚拟化中的应用，已经把网络，存储中断减少到了0。
内部中断源包括时钟，性能监控，错误检测，温度传感器。这几个中断，绝大多数日常使用虚拟机情况下发生频率极低。对虚拟化的开销影响很小。
IPI中断是多核CPU系统中CPU彼此通信的唯一方法。主要使用在分布在不同CPU上的进程/线程彼此唤醒的情况中。比较常见的是网络场景，比如有请求到达时唤醒后端网络服务程序，比如：redis，nginx。以及整合了网络服务的别的系统。比如：mysql。

目前公有云中，中断虚拟化中性能瓶颈点落在了IPI中断中。

如何向vcpu注入中断？是通过向真实CPU模拟注入NMI（非可屏蔽中断）中断来实现。
KVM要模拟一个中断控制芯片，这个是通过KVM_CREATE_IRQCHIP来实现的。

实际上注入中断就是写vmcs里面的VM_ENTRY_INTR_INFO_FIELD这个域。然后在vcpu的run函数里面设置cpu进入非根模式，vcpu会自动检查vmcs结构，然后注入中断，这是硬件自动完成的工作。而处理中断，这就是另外一个故事了，不知道后面有没有篇幅和时间继续看下吧。

# 中断发布
Interrupt-posting是中断重映射功能的一个扩展功能，该功能也是针对的可重映射中断请求。Interrupt-posting功能让一个可重映射的中断请求能够被暂时以一定的数据形式post（记录）到物理内存中，并且可选择性地主动告知CPU物理内存中暂时记录着pending的中断请求。经Interrupt-posting扩展后的中断处理过程如下图。

VT-d重映射硬件是否支持Interrupt-posting功能可以通过查询Capability Register的bit 59 “Posted Interrupt Support（PI）”是否为1判断。对于VT-d而言，所有可重映射中断都需要经过IRTE的处理，在进行处理之前会先通过IRTE的bit 15（IRTE Mode）判断该IRTE的模式，如果为0，则VT-d硬件将会以Remapped Interrupt的形式来解析该IRTE，如果为1，则VT-d硬件将会以Posted Interrupt的形式来解析该IRTE，格式如下图所示：
![alt text](../../medias/images_0/中断虚拟化_image-2.png)



# Posted Interrupt Descriptor
从软件的角度来看，VMM可能会对Interrupt Posting做如下设置和操作：
■ 对于每个vCPU而言，VMM都会分配一个对应的Posted Interrupt Descriptor用于记录和传递经过重定向，并且目的地为对应vCPU的所有中断请求。
■ VMM软件为所有的Notification Event分配两个物理中断vector：
    ● 第一个称作Active Notification Vector（ANV），该Vector对应到当中断目标vCPU当前正在被逻辑CPU执行（即vCPU的状态为active）时，Notification Event所使用的中断vector。
    ● 第二个称作Wake-up Notification Vector（WNV），该Vector对应到中断目标vCPU当前不在逻辑CPU上被执行时，由于Urgent被置起来产生的Notification Event所使用的中断Vector。
■ 对于从直接分配给VM的I/O设备产生的中断而言，VMM会为每个这样的中断分配一个IRTE。并且VMM可能会为vCPU使能硬件上的APIC Virtualization，APIC Virtualization主要包括两方面功能：virtual-interrupt delivery和process posted-interrupts，其主要工作形式表现在：
    ● 当一个vCPU被VMM调度即将执行的时候，该vCPU的状态为active，该状态的一个表现形式是VMM会将Posted Interrupt Descriptor的Notification Vector字段设置为ANV（Active Notification Vector）。这样就允许当这个vCPU在逻辑CPU上执行的时候，所有指向该vCPU的中断都能够直接被该vCPU处理，不需要经过VMM。vCPU通过将记录在Posted Interrupt Descriptor中的中断直接转移到Virtual-APIC Page中，并直接将中断信号传递给vCPU，让vCPU直接获取到该中断信号的方式来处理Notification Event。
    ● 当一个vCPU被抢占后，即vCPU的状态为ready-to-run，该状态的一个表现形式是VMM会将Posted Interrupt Descriptor的Notification Vector字段设置为WNV（Wake-up Notification Vector），并且SN（Suppress Notification）设置为1。只有当接收到的中断请求为Urgent的时候，才会发出Notification Event，触发VMM的执行，让VMM调度目标vCPU处理该紧急中断。
    ● 当一个vCPU处于Halt状态的时候，逻辑CPU执行VMM软件，VMM将该vCPU标记为halted状态。该状态的一个表现形式就是将Posted Interrupt Descriptor的Notification Vector字段设置为WNV（Wake-up Notification Vector），并且SN（Suppress Notification）设置为0，即任何到达该Posted Interrupt Descriptor的中断请求都会触发Notification Event，让VMM唤醒vCPU，让vCPU处理中断请求。

■ 当VMM调度并执行一个vCPU的时候，VMM会对被记录到Posted Interrupt Descriptor的中断请求进行处理：
    ● 首先，VMM会通过将Posted Interrupt Descriptor的Notification Vector字段的值改为ANV将vCPU的状态变为active。
    ● VMM检测在Posted Interrupt Descriptor中是否有待处理的中断请求。
    ● 如果有待处理的中断请求，则VMM会给当前CPU发送一个sefl-IPI中断（即CPU自己给自己发送一个中断），并且中断向量值为ANV。当vCPU一使能中断的时候，就能够立马识别到该中断。该中断的处理类似于vCPU处于active状态时，接收到了Active Notification Vector的中断请求，vCPU可以直接对其进行处理，不需要VMM的参与。
■ VMM也可以利用Posted Interrupt的处理机制，通过设置Posted Interrupt Descriptor向vCPU注入中断请求。

PS：Interrupt Posting的一个前提是CPU支持posted-interrupt processing。posted-interrupt下，当虚拟中断芯片需要注入中断时，其将中断信息更新到Posted Interrupt Descriptor中，然后虚拟中断芯片向CPU发送一个通知posted-interrupt notification，处于Guest模式的CPU通过VMCS记录的virtual-APIC page收到这个中断后，运行Guest的硬件中断评估逻辑，直接响应中断。这个中断通知并不特殊，就是一个常规的IPI，但是核间中断向量是专有的，目的CPU收到这个IPI后，不再触发VM exit，而是去处理被虚拟中断芯片写在Posted Interrupt Descriptor中的中断。

![alt text](../../medias/images_0/中断虚拟化_image.png)
设备透传场景下，RC上iommu的Interrupt Posting和CPU的posted-interrupt相结合后，iommu代替KVM的virtual LAPIC，负责更新目标Guest的Posted Interrupt Descriptor。
![alt text](../../medias/images_0/中断虚拟化_image-1.png)
Interrupt Posting功能在虚拟化环境中，能够防止外部中断频繁打断vCPU的运行，提高系统的性能。

# DMAR表组织结构